itemFrequencyPlot(data,topN=20,type="absolute")
rules <- apriori(data, parameter = list(supp = 0.001, conf = 0.8))
rules <- apriori(data, parameter = list(supp = 0.002, conf = 0.9))
options(digits=2)
inspect(rules[1:5])
View(data)
View(data)
data <- read.csv("C:/wamp/www/apriori/data.json")
View(data)
View(data)
data <- read.csv("C:/wamp/www/apriori/data.json", quote="")
View(data)
install.packages(rjosn)
install.packages(rjson)
install.packages("rjson")
json_file <- "C:\wamp\www\apriori\data.json"
json_file <- "C:\\wamp\\www\\apriori\\data.json"
json_data <- fromJSON(paste(readLines(json_file), collapse=""))
json_data <- fromJSON(file=json_file)
json_file
library(rjson)
json_data <- fromJSON(paste(readLines(json_file), collapse=""))
library(arules)
library(arulesViz)
summary(json_data)
rules<-apriori(json_data,parameter=list(supp=.02, conf=.9, target="rules"))
apriori(json_data,parameter=list(supp=.02, conf=.9, target="rules"))
trans <- as(json_data, "transactions")
names(json_data)
json_data
names(json_data) <- paste("Tr",c(1:100), sep = "")
json_data
names(json_data) <- paste("Tr",c(1:200), sep = "")
json_data
trans <- as(json_data, "transactions")
json_data <- unique(json_data)
length(json_data)
names(json_data) <- paste("Tr",c(1:186), sep = "")
json_data
apriori(json_data,parameter=list(supp=.02, conf=.9, target="rules"))
trans <- as(json_data, "transactions")
trans <- as(split(json_data$items, json_data[, "Tr"] ), "transactions")
trans <- as(split(json_data$items, json_data[, "Tr186"] ), "transactions")
trans <- as(split(json_data$items, json_data[0, "Tr186"] ), "transactions")
trans <- as(split(json_data$items, json_data[0, "Tr"] ), "transactions")
names(json_data) <- paste("Tr", sep = "")
json_data
names(json_data) <- paste("Tr",c(), sep = "")
json_data
names(json_data) <- paste("Tr",c(1:186))
json_data
json_file <- "C:\\wamp\\www\\apriori\\data.json"
json_file
json_data <- fromJSON(file=json_file)
json_data
names(json_data) <- paste("Tr",c(1:100), sep = "")
json_data
names(json_data) <- paste("Tr",c(1:186), sep = "")
json_data
json_data<-unique(json_data)
json_data
list(json_data)
json_file <- "C:\\wamp\\www\\apriori\\data.json"
json_data <- fromJSON(file=json_file)
list(json_data)
json_data<-unique(list(json_data))
list(json_data)
load("C:/Users/mahid/Downloads/titanic.raw (1).rdata")
View(titanic.raw)
View(titanic.raw)
libary(rjson)
library(rjson)
library(arules)
data <- fromJSON("c:\\wamp\\www\\apriori\\data.json")
data <- fromJSON("C:\\wamp\\www\\apriori\\data.json")
data <- fromJSON(file = "C:\\wamp\\www\\apriori\\data.json")
names(data) <- paste("Order",c(1:10000), sep = "")
trans <- as(data, "transactions")
inspect(trans)
rules<-apriori(trans,parameter=list(supp=.02, conf=.5, target="rules"))
rules<-apriori(trans,parameter=list(supp=.02, conf=.3, target="rules"))
inspect(head(sort(rules,by="lift"),n=20))
rules<-apriori(trans,parameter=list(supp=.01, conf=.3, target="rules"))
rules<-apriori(trans,parameter=list(supp=.1, conf=.3, target="rules"))
rules<-apriori(trans,parameter=list(supp=.5, conf=.3, target="rules"))
rules<-apriori(trans,parameter=list(supp=.2, conf=.3, target="rules"))
inspect(head(sort(rules,by="lift"),n=20))
rules<-apriori(trans,parameter=list(supp=.2, conf=.5, target="rules"))
retail <- read.table("D:/Classes/Summer 2016/Knowledge Discovery in Databases/retail.dat", quote="\"", comment.char="")
View(retail)
library(rjson)
library(arules)
data<-fromJSON("C:\\wamp\\www\\apriori\\data.json")
data<-fromJSON(file = "C:\\wamp\\www\\apriori\\data.json")
data
names(data) <- paste("Tr",c(1:10000), sep = "")
trans <- as(data, "transactions")
rules<-apriori(trans,parameter=list(supp=.02, conf=.5, target="rules", minlen=2))
rules<-apriori(trans,parameter=list(supp=.005, conf=.4, target="rules", minlen=2))
rules<-apriori(trans,parameter=list(supp=.005, conf=.3, target="rules", minlen=2))
rules<-apriori(trans,parameter=list(supp=.005, conf=.2, target="rules", minlen=2))
inspect(head(sort(rules,by="lift"),n=20))
rules<-apriori(trans,parameter=list(supp=.1, conf=.2, target="rules", minlen=2))
rules<-apriori(trans,parameter=list(supp=.05, conf=.2, target="rules", minlen=2))
rules<-apriori(trans,parameter=list(supp=.05, conf=.3, target="rules", minlen=2))
rules<-apriori(trans,parameter=list(supp=.05, conf=.2, target="rules", minlen=2))
inspect(head(sort(rules,by="lift"),n=20))
data<-fromJSON(file = "C:\\wamp\\www\\apriori\\data.json")
names(data) <- paste("Order",c(1:10000), sep = "")
trans <- as(data, "transactions")
rules<-apriori(trans,parameter=list(supp=.05, conf=.2, target="rules", minlen=2))
inspect(head(sort(rules,by="lift"),n=20))
plot(rules, method="grouped")
library("arulesViz")
plot(rules, method="grouped")
setwd('D:/Classes/Fall 2016/Machine Learning/HW4/ML_SVM_HW4/ML_SVM_HW4/')
pkgs <- c( 'ggplot2', 'kernlab', 'ROCR' )
install.packages( pkgs )
load('linear1.RData')
require( 'ggplot2' )
qplot( data=linear1.data, x.1, x.2, colour=factor(y), shape=factor(train) )
require( 'kernlab' )
linear1.svm <- ksvm( y ~ ., data=linear1.train, type='C-svc', kernel='vanilladot',C=100, scale=c() )
linear1.svm
attributes(linear1.svm)
alpha(linear1.svm)
alphaindex(linear1.svm)
b(linear1.svm)
plot( linear1.svm, data=linear1.train )
points( linear1.test.input[ sample.int(nrow(linear1.test.input),10), ], pch=4 )
linear1.prediction <- predict( linear1.svm, linear1.test.input )
load('linear1Sol.RData')
print(paste0('Accuracy: ', 100*sum( linear1.prediction == linear1.test.output )/length(linear1.test.output), '%'))
load('linear2.RData')
require( 'ggplot2' )
qplot( data=linear2.data, x.1, x.2, colour=factor(y), shape=factor(train) )
require( 'kernlab' )
linear2.svm <- ksvm( y ~ ., data=linear2.train, type='C-svc', kernel='vanilladot',C=100, scale=c() )
plot( linear2.svm, data=linear2.train )
linear2.prediction <- predict( linear2.svm, linear2.test.input)
load('linear2Sol.RData')
print(paste0('Accuracy: ', 100*sum( linear2.prediction == linear2.test.output )/length(linear2.test.output), '%'))
print('Confusion Matrix: ');print(table( linear2.prediction, linear2.test.output, dnn= c("prediction","reality") ))
linear2.prediction.score <- predict( linear2.svm, linear2.test.input, type='decision' )
require( 'ROCR' )
linear2.roc.curve <- performance( prediction( linear2.prediction.score, linear2.test.output ), measure='tpr', x.measure='fpr' )
plot( linear2.roc.curve )
linear2.pr.curve <- performance( prediction( linear2.prediction.score, linear2.test.output ), measure='prec', x.measure='rec' )
plot( linear2.pr.curve )
load('nonlinear.RData')
qplot( data=nonlinear.data, x.1, x.2, colour=factor(y), shape=factor(train) )
badlinear.svm <- ksvm( y ~ ., data=nonlinear.train, type='C-svc', kernel='vanilladot', C=100, scale=c() )
plot( badlinear.svm, data=nonlinear.train )
nonlinear.svm <- ksvm( y ~ ., data=nonlinear.train, type='C-svc', kernel='rbf', kpar=list(sigma=1), C=100, scale=c() )
plot( nonlinear.svm, data=nonlinear.train )
require('manipulate')
manipulate( plot(ksvm( y ~ ., data=nonlinear.train, type='C-svc', kernel=k, C=2^c.exponent, scale=c() ), data=nonlinear.train ), c.exponent=slider(-10,10),
k=picker('Gaussian'='rbfdot', 'Linear'='vanilladot', 'Hyperbolic'='tanhdot','Spline'='splinedot', 'Laplacian'='laplacedot') )
install.packages("manipulate")
require('manipulate')
manipulate( plot(ksvm( y ~ ., data=nonlinear.train, type='C-svc', kernel=k, C=2^c.exponent, scale=c() ), data=nonlinear.train ), c.exponent=slider(-10,10),
k=picker('Gaussian'='rbfdot', 'Linear'='vanilladot', 'Hyperbolic'='tanhdot','Spline'='splinedot', 'Laplacian'='laplacedot') )
nonlinear.svm <- ksvm( y ~ ., data=nonlinear.train, type='C-svc', kernel='rbf', kpar=list(sigma=1), C=100, scale=c() )
plot( nonlinear.svm, data=nonlinear.train )
nonLinear.prediction <- predict( nonlinear.svm, nonlinear.test.input)
load('nonlinearSol.RData')
print(paste0('Accuracy: ', 100*sum( nonLinear.prediction == nonlinear.test.output )/length(nonlinear.test.output), '%'))
print('Confusion Matrix: ');print(table( nonLinear.prediction, nonlinear.test.output, dnn= c("prediction","reality") ))
nonLinear.prediction.score <- predict( nonlinear.svm, nonlinear.test.input, type='decision' )
require( 'ROCR' )
nonLinear.roc.curve <- performance( prediction( nonLinear.prediction.score, nonlinear.test.output ), measure='tpr', x.measure='fpr' )
plot( nonLinear.roc.curve )
nonLinear.pr.curve <- performance( prediction( nonLinear.prediction.score, nonlinear.test.output ), measure='prec', x.measure='rec' )
plot( nonLinear.pr.curve )
BiasVarianceTradeoff <- function( dataset, cross=10, c.seq=2^seq(-10, 10), ... ) {
err <- sapply( c.seq, function( c )
{
cross( ksvm( y ~ ., data=dataset, C=c, cross=cross, ...) )
})
return(data.frame( c=c.seq, error=err ))
}
qplot( c, error, data=BiasVarianceTradeoff( nonlinear.train, type='C-svc', kernel='rbfdot' ), geom='line', log='x' )
pkgs <- c( 'ggplot2', 'kernlab', 'ROCR' )
install.packages( pkgs )
install.packages(pkgs)
install.packages(pkgs)
install.packages(pkgs)
install.packages(pkgs)
install.packages(pkgs)
load('linear1.RData')
require( 'ggplot2' )
qplot( data=linear1.data, x.1, x.2, colour=factor(y), shape=factor(train) )
qplot( data=linear1.data, x.1, x.2, colour=factor(y), shape=factor(train) )
require( 'kernlab' )
linear1.svm <- ksvm( y ~ ., data=linear1.train, type='C-svc', kernel='vanilladot',C=100, scale=c() )
linear1.svm
attributes(linear1.svm)
alpha(linear1.svm)
alphaindex(linear1.svm)
b(linear1.svm)
plot( linear1.svm, data=linear1.train )
linear1.svm <- ksvm( y ~ ., data=linear1.train, type='C-svc', kernel='vanilladot',C=10, scale=c() )
linear1.svm
attributes(linear1.svm)
alpha(linear1.svm)
alphaindex(linear1.svm)
b(linear1.svm)
plot( linear1.svm, data=linear1.train )
points( linear1.test.input[ sample.int(nrow(linear1.test.input),10), ], pch=4 )
linear1.prediction <- predict( linear1.svm, linear1.test.input )
load('linear1Sol.RData')
print(paste0('Accuracy: ', 100*sum( linear1.prediction == linear1.test.output )/length(linear1.test.output), '%'))
load('linear2.RData')
linear1.svm <- ksvm( y ~ ., data=linear1.train, type='C-svc', kernel='vanilladot',C=30, scale=c() )
linear1.svm
attributes(linear1.svm)
alpha(linear1.svm)
alphaindex(linear1.svm)
b(linear1.svm)
plot( linear1.svm, data=linear1.train )
points( linear1.test.input[ sample.int(nrow(linear1.test.input),10), ], pch=4 )
linear1.prediction <- predict( linear1.svm, linear1.test.input )
load('linear1Sol.RData')
print(paste0('Accuracy: ', 100*sum( linear1.prediction == linear1.test.output )/length(linear1.test.output), '%'))
linear1.svm <- ksvm( y ~ ., data=linear1.train, type='C-svc', kernel='vanilladot',C=200, scale=c() )
linear1.svm
attributes(linear1.svm)
alpha(linear1.svm)
alphaindex(linear1.svm)
b(linear1.svm)
plot( linear1.svm, data=linear1.train )
points( linear1.test.input[ sample.int(nrow(linear1.test.input),10), ], pch=4 )
linear1.prediction <- predict( linear1.svm, linear1.test.input )
load('linear1Sol.RData')
print(paste0('Accuracy: ', 100*sum( linear1.prediction == linear1.test.output )/length(linear1.test.output), '%'))
linear1.svm <- ksvm( y ~ ., data=linear1.train, type='C-svc', kernel='vanilladot',C=500, scale=c() )
linear1.svm
attributes(linear1.svm)
alpha(linear1.svm)
alphaindex(linear1.svm)
b(linear1.svm)
plot( linear1.svm, data=linear1.train )
points( linear1.test.input[ sample.int(nrow(linear1.test.input),10), ], pch=4 )
linear1.prediction <- predict( linear1.svm, linear1.test.input )
load('linear1Sol.RData')
print(paste0('Accuracy: ', 100*sum( linear1.prediction == linear1.test.output )/length(linear1.test.output), '%'))
linear1.svm <- ksvm( y ~ ., data=linear1.train, type='C-svc', kernel='vanilladot',C=1000, scale=c() )
linear1.svm
attributes(linear1.svm)
alpha(linear1.svm)
alphaindex(linear1.svm)
b(linear1.svm)
plot( linear1.svm, data=linear1.train )
points( linear1.test.input[ sample.int(nrow(linear1.test.input),10), ], pch=4 )
linear1.prediction <- predict( linear1.svm, linear1.test.input )
load('linear1Sol.RData')
print(paste0('Accuracy: ', 100*sum( linear1.prediction == linear1.test.output )/length(linear1.test.output), '%'))
linear1.svm <- ksvm( y ~ ., data=linear1.train, type='C-svc', kernel='vanilladot',C=0, scale=c() )
linear1.svm
attributes(linear1.svm)
alpha(linear1.svm)
alphaindex(linear1.svm)
b(linear1.svm)
plot( linear1.svm, data=linear1.train )
points( linear1.test.input[ sample.int(nrow(linear1.test.input),10), ], pch=4 )
linear1.prediction <- predict( linear1.svm, linear1.test.input )
load('linear1Sol.RData')
print(paste0('Accuracy: ', 100*sum( linear1.prediction == linear1.test.output )/length(linear1.test.output), '%'))
linear1.svm <- ksvm( y ~ ., data=linear1.train, type='C-svc', kernel='vanilladot',C=1, scale=c() )
linear1.svm
attributes(linear1.svm)
alpha(linear1.svm)
alphaindex(linear1.svm)
b(linear1.svm)
plot( linear1.svm, data=linear1.train )
points( linear1.test.input[ sample.int(nrow(linear1.test.input),10), ], pch=4 )
linear1.prediction <- predict( linear1.svm, linear1.test.input )
load('linear1Sol.RData')
print(paste0('Accuracy: ', 100*sum( linear1.prediction == linear1.test.output )/length(linear1.test.output), '%'))
linear2.svm <- ksvm( y ~ ., data=linear2.train, type='C-svc', kernel='vanilladot',C=100, scale=c() )
plot( linear2.svm, data=linear2.train )
linear2.prediction <- predict( linear2.svm, linear2.test.input)
load('linear2Sol.RData')
require( 'ggplot2' )
load('linear2.RData')
require( 'ggplot2' )
qplot( data=linear2.data, x.1, x.2, colour=factor(y), shape=factor(train) )
linear1.svm <- ksvm( y ~ ., data=linear1.train, type='C-svc', kernel='vanilladot',C=100000, scale=c() )
linear1.svm
attributes(linear1.svm)
alpha(linear1.svm)
alphaindex(linear1.svm)
b(linear1.svm)
plot( linear1.svm, data=linear1.train )
points( linear1.test.input[ sample.int(nrow(linear1.test.input),10), ], pch=4 )
linear1.prediction <- predict( linear1.svm, linear1.test.input )
load('linear1Sol.RData')
print(paste0('Accuracy: ', 100*sum( linear1.prediction == linear1.test.output )/length(linear1.test.output), '%'))
load('linear2.RData')
require( 'ggplot2' )
qplot( data=linear2.data, x.1, x.2, colour=factor(y), shape=factor(train) )
require( 'kernlab' )
linear2.svm <- ksvm( y ~ ., data=linear2.train, type='C-svc', kernel='vanilladot',C=100, scale=c() )
plot( linear2.svm, data=linear2.train )
linear2.prediction <- predict( linear2.svm, linear2.test.input)
load('linear2Sol.RData')
print(paste0('Accuracy: ', 100*sum( linear2.prediction == linear2.test.output )/length(linear2.test.output), '%'))
print('Confusion Matrix: ');print(table( linear2.prediction, linear2.test.output, dnn= c("prediction","reality") ))
linear2.prediction.score <- predict( linear2.svm, linear2.test.input, type='decision' )
require( 'ROCR' )
linear2.roc.curve <- performance( prediction( linear2.prediction.score, linear2.test.output ), measure='tpr', x.measure='fpr' )
plot( linear2.roc.curve )
linear2.prediction.score
linear2.roc.curve <- performance( prediction( linear2.prediction.score, linear2.test.output ), measure='tpr', x.measure='fpr' )
plot( linear2.roc.curve )
linear2.pr.curve <- performance( prediction( linear2.prediction.score, linear2.test.output ), measure='prec', x.measure='rec' )
plot( linear2.pr.curve )
linear2.roc.curve <- performance( prediction( linear2.prediction.score, linear2.test.output ), measure='tpr', x.measure='fpr' )
plot( linear2.roc.curve )
linear2.roc.auc
linear2.roc.curve
linear2.roc.curve.auc
linear2.svm <- ksvm( y ~ ., data=linear2.train, type='C-svc', kernel='vanilladot',C=10000, scale=c() )
plot( linear2.svm, data=linear2.train )
linear2.prediction <- predict( linear2.svm, linear2.test.input)
load('linear2Sol.RData')
print(paste0('Accuracy: ', 100*sum( linear2.prediction == linear2.test.output )/length(linear2.test.output), '%'))
print('Confusion Matrix: ');print(table( linear2.prediction, linear2.test.output, dnn= c("prediction","reality") ))
linear2.prediction.score <- predict( linear2.svm, linear2.test.input, type='decision' )
require( 'ROCR' )
linear2.roc.curve <- performance( prediction( linear2.prediction.score, linear2.test.output ), measure='tpr', x.measure='fpr' )
plot( linear2.roc.curve )
linear2.pr.curve <- performance( prediction( linear2.prediction.score, linear2.test.output ), measure='prec', x.measure='rec' )
plot( linear2.pr.curve )
load('nonlinear.RData')
qplot( data=nonlinear.data, x.1, x.2, colour=factor(y), shape=factor(train) )
badlinear.svm <- ksvm( y ~ ., data=nonlinear.train, type='C-svc', kernel='vanilladot', C=100, scale=c() )
plot( badlinear.svm, data=nonlinear.train )
nonlinear.svm <- ksvm( y ~ ., data=nonlinear.train, type='C-svc', kernel='rbf', kpar=list(sigma=1), C=100, scale=c() )
plot( nonlinear.svm, data=nonlinear.train )
require('manipulate')
manipulate( plot(ksvm( y ~ ., data=nonlinear.train, type='C-svc', kernel=k, C=2^c.exponent, scale=c() ), data=nonlinear.train ), c.exponent=slider(-10,10),
k=picker('Gaussian'='rbfdot', 'Linear'='vanilladot', 'Hyperbolic'='tanhdot','Spline'='splinedot', 'Laplacian'='laplacedot') )
nonlinear.svm <- ksvm( y ~ ., data=nonlinear.train, type='C-svc', kernel='rbf', kpar=list(sigma=1), C=100, scale=c() )
plot( nonlinear.svm, data=nonlinear.train )
nonLinear.prediction <- predict( nonlinear.svm, nonlinear.test.input)
load('nonlinearSol.RData')
print(paste0('Accuracy: ', 100*sum( nonLinear.prediction == nonlinear.test.output )/length(nonlinear.test.output), '%'))
print('Confusion Matrix: ');print(table( nonLinear.prediction, nonlinear.test.output, dnn= c("prediction","reality") ))
nonLinear.prediction.score <- predict( nonlinear.svm, nonlinear.test.input, type='decision' )
require( 'ROCR' )
nonLinear.roc.curve <- performance( prediction( nonLinear.prediction.score, nonlinear.test.output ), measure='tpr', x.measure='fpr' )
plot( nonLinear.roc.curve )
nonLinear.pr.curve <- performance( prediction( nonLinear.prediction.score, nonlinear.test.output ), measure='prec', x.measure='rec' )
plot( nonLinear.pr.curve )
BiasVarianceTradeoff <- function( dataset, cross=10, c.seq=2^seq(-10, 10), ... ) {
err <- sapply( c.seq, function( c )
{
cross( ksvm( y ~ ., data=dataset, C=c, cross=cross, ...) )
})
return(data.frame( c=c.seq, error=err ))
}
qplot( c, error, data=BiasVarianceTradeoff( nonlinear.train, type='C-svc', kernel='rbfdot' ), geom='line', log='x' )
nonlinear.svm <- ksvm( y ~ ., data=nonlinear.train, type='C-svc', kernel='rbf', kpar=list(sigma=1), C=100, scale=c() )
plot( nonlinear.svm, data=nonlinear.train )
nonlinear.svm <- ksvm( y ~ ., data=nonlinear.train, type='C-svc', kernel='rbf', kpar=list(sigma=1), C=100, scale=c() )
plot( nonlinear.svm, data=nonlinear.train )
require('manipulate')
manipulate( plot(ksvm( y ~ ., data=nonlinear.train, type='C-svc', kernel=k, C=2^c.exponent, scale=c() ), data=nonlinear.train ), c.exponent=slider(-10,10),
k=picker('Gaussian'='rbfdot', 'Linear'='vanilladot', 'Hyperbolic'='tanhdot','Spline'='splinedot', 'Laplacian'='laplacedot') )
linear1.svm <- ksvm( y ~ ., data=linear1.train, type='C-svc', kernel='vanilladot',C=100000, scale=c() )
linear1.svm <- ksvm( y ~ ., data=linear1.train, type='C-svc', kernel='vanilladot',C=-5, scale=c() )
linear1.svm
attributes(linear1.svm)
alpha(linear1.svm)
alphaindex(linear1.svm)
b(linear1.svm)
plot( linear1.svm, data=linear1.train )
points( linear1.test.input[ sample.int(nrow(linear1.test.input),10), ], pch=4 )
linear1.prediction <- predict( linear1.svm, linear1.test.input )
load('linear1Sol.RData')
print(paste0('Accuracy: ', 100*sum( linear1.prediction == linear1.test.output )/length(linear1.test.output), '%'))
nonlinear.svm <- ksvm( y ~ ., data=nonlinear.train, type='C-svc', kernel='rbf', kpar=list(sigma=1), C=100, scale=c() )
plot( nonlinear.svm, data=nonlinear.train )
require('manipulate')
nonlinear.svm <- ksvm( y ~ ., data=nonlinear.train, type='C-svc', kernel='rbf', kpar=list(sigma=1), C=100, scale=c() )
plot( nonlinear.svm, data=nonlinear.train )
require('manipulate')
manipulate( plot(ksvm( y ~ ., data=nonlinear.train, type='C-svc', kernel=k, C=2^c.exponent, scale=c() ), data=nonlinear.train ), c.exponent=slider(-10,10),
k=picker('Gaussian'='rbfdot', 'Linear'='vanilladot', 'Hyperbolic'='tanhdot','Spline'='splinedot', 'Laplacian'='laplacedot') )
qplot( data=nonlinear.data, x.1, x.2, colour=factor(y), shape=factor(train) )
badlinear.svm <- ksvm( y ~ ., data=nonlinear.train, type='C-svc', kernel='vanilladot', C=100, scale=c() )
plot( badlinear.svm, data=nonlinear.train )
nonLinear.roc.curve <- performance( prediction( nonLinear.prediction.score, nonlinear.test.output ), measure='tpr', x.measure='fpr' )
plot( nonLinear.roc.curve )
qplot( data=nonlinear.data, x.1, x.2, colour=factor(y), shape=factor(train) )
badlinear.svm <- ksvm( y ~ ., data=nonlinear.train, type='C-svc', kernel='vanilladot', C=100, scale=c() )
plot( badlinear.svm, data=nonlinear.train )
require( 'ROCR' )
nonLinear.roc.curve <- performance( prediction( nonLinear.prediction.score, nonlinear.test.output ), measure='tpr', x.measure='fpr' )
plot( nonLinear.roc.curve )
badlinear.svm <- ksvm( y ~ ., data=nonlinear.train, type='C-svc', kernel='vanilladot', C=100, scale=c() )
plot( badlinear.svm, data=nonlinear.train )
nonLinear.prediction <- predict( nonlinear.svm, nonlinear.test.input)
load('nonlinearSol.RData')
print(paste0('Accuracy: ', 100*sum( nonLinear.prediction == nonlinear.test.output )/length(nonlinear.test.output), '%'))
print('Confusion Matrix: ');print(table( nonLinear.prediction, nonlinear.test.output, dnn= c("prediction","reality") ))
nonLinear.prediction.score <- predict( nonlinear.svm, nonlinear.test.input, type='decision' )
require( 'ROCR' )
nonLinear.roc.curve <- performance( prediction( nonLinear.prediction.score, nonlinear.test.output ), measure='tpr', x.measure='fpr' )
plot( nonLinear.roc.curve )
plot( badlinear.svm, data=nonlinear.train )
nonlinear.svm <- ksvm( y ~ ., data=nonlinear.train, type='C-svc', kernel='rbf', kpar=list(sigma=1), C=100, scale=c() )
plot( nonlinear.svm, data=nonlinear.train )
nonlinear.svm <- ksvm( y ~ ., data=nonlinear.train, type='C-svc', kernel='rbf', kpar=list(sigma=1), C=100, scale=c() )
plot( nonlinear.svm, data=nonlinear.train )
nonLinear.prediction <- predict( nonlinear.svm, nonlinear.test.input)
load('nonlinearSol.RData')
print(paste0('Accuracy: ', 100*sum( nonLinear.prediction == nonlinear.test.output )/length(nonlinear.test.output), '%'))
nonLinear.prediction <- predict( nonlinear.svm, nonlinear.test.input)
load('nonlinearSol.RData')
print(paste0('Accuracy: ', 100*sum( nonLinear.prediction == nonlinear.test.output )/length(nonlinear.test.output), '%'))
print('Confusion Matrix: ');print(table( nonLinear.prediction, nonlinear.test.output, dnn= c("prediction","reality") ))
nonLinear.prediction.score <- predict( nonlinear.svm, nonlinear.test.input, type='decision' )
require( 'ROCR' )
nonLinear.roc.curve <- performance( prediction( nonLinear.prediction.score, nonlinear.test.output ), measure='tpr', x.measure='fpr' )
plot( nonLinear.roc.curve )
require('manipulate')
manipulate( plot(ksvm( y ~ ., data=nonlinear.train, type='C-svc', kernel=k, C=2^c.exponent, scale=c() ), data=nonlinear.train ), c.exponent=slider(-10,10),
k=picker('Gaussian'='rbfdot', 'Linear'='vanilladot', 'Hyperbolic'='tanhdot','Spline'='splinedot', 'Laplacian'='laplacedot') )
nonlinear.svm <- ksvm( y ~ ., data=nonlinear.train, type='C-svc', kernel='rbf', kpar=list(sigma=1), C=100, scale=c() )
plot( nonlinear.svm, data=nonlinear.train )
nonlinear.svm <- ksvm( y ~ ., data=nonlinear.train, type='C-svc', kernel='rbf', kpar=list(sigma=1), C=100, scale=c() )
plot( nonlinear.svm, data=nonlinear.train )
nonLinear.prediction <- predict( nonlinear.svm, nonlinear.test.input)
load('nonlinearSol.RData')
print(paste0('Accuracy: ', 100*sum( nonLinear.prediction == nonlinear.test.output )/length(nonlinear.test.output), '%'))
print('Confusion Matrix: ');print(table( nonLinear.prediction, nonlinear.test.output, dnn= c("prediction","reality") ))
nonLinear.prediction.score <- predict( nonlinear.svm, nonlinear.test.input, type='decision' )
require( 'ROCR' )
nonLinear.roc.curve <- performance( prediction( nonLinear.prediction.score, nonlinear.test.output ), measure='tpr', x.measure='fpr' )
plot( nonLinear.roc.curve )
badlinear.prediction <- predict( badlinear.svm, nonlinear.test.input)
qplot( data=nonlinear.data, x.1, x.2, colour=factor(y), shape=factor(train) )
load('nonlinear.RData')
qplot( data=nonlinear.data, x.1, x.2, colour=factor(y), shape=factor(train) )
badlinear.svm <- ksvm( y ~ ., data=nonlinear.train, type='C-svc', kernel='vanilladot', C=100, scale=c() )
plot( badlinear.svm, data=nonlinear.train )
badlinear.prediction <- predict( badlinear.svm, nonlinear.test.input)
load('nonlinearSol.RData')
print(paste0('Accuracy: ', 100*sum( badlinear.prediction == nonlinear.test.output )/length(nonlinear.test.output), '%'))
print('Confusion Matrix: ');print(table( badlinear.prediction, nonlinear.test.output, dnn= c("prediction","reality") ))
badlinear.prediction.score <- predict( badlinear.svm, nonlinear.test.input, type='decision' )
require( 'ROCR' )
badLinear.roc.curve <- performance( prediction( badLinear.prediction.score, nonlinear.test.output ), measure='tpr', x.measure='fpr' )
badlinear.roc.curve <- performance( prediction( badLinear.prediction.score, nonlinear.test.output ), measure='tpr', x.measure='fpr' )
badlinear.roc.curve <- performance( prediction( badlinear.prediction.score, nonlinear.test.output ), measure='tpr', x.measure='fpr' )
plot( badlinear.roc.curve )
nonlinear.svm <- ksvm( y ~ ., data=nonlinear.train, type='C-svc', kernel='rbf', kpar=list(sigma=1), C=100, scale=c() )
plot( nonlinear.svm, data=nonlinear.train )
require('manipulate')
manipulate( plot(ksvm( y ~ ., data=nonlinear.train, type='C-svc', kernel=k, C=2^c.exponent, scale=c() ), data=nonlinear.train ), c.exponent=slider(-10,10),
k=picker('Gaussian'='rbfdot', 'Linear'='vanilladot', 'Hyperbolic'='tanhdot','Spline'='splinedot', 'Laplacian'='laplacedot') )
nonLinear.prediction <- predict( nonlinear.svm, nonlinear.test.input)
load('nonlinearSol.RData')
print(paste0('Accuracy: ', 100*sum( nonLinear.prediction == nonlinear.test.output )/length(nonlinear.test.output), '%'))
print('Confusion Matrix: ');print(table( nonLinear.prediction, nonlinear.test.output, dnn= c("prediction","reality") ))
nonLinear.prediction.score <- predict( nonlinear.svm, nonlinear.test.input, type='decision' )
require( 'ROCR' )
nonLinear.roc.curve <- performance( prediction( nonLinear.prediction.score, nonlinear.test.output ), measure='tpr', x.measure='fpr' )
plot( nonLinear.roc.curve )
nonlinear.svm <- ksvm( y ~ ., data=nonlinear.train, type='laplacedot', kernel='rbf', kpar=list(sigma=1), C=4, scale=c() )
nonlinear.svm <- ksvm( y ~ ., data=nonlinear.train, type='C-svc', kernel='laplacedot', kpar=list(sigma=1), C=4, scale=c() )
plot( nonlinear.svm, data=nonlinear.train )
nonLinear.prediction <- predict( nonlinear.svm, nonlinear.test.input)
load('nonlinearSol.RData')
print(paste0('Accuracy: ', 100*sum( nonLinear.prediction == nonlinear.test.output )/length(nonlinear.test.output), '%'))
print('Confusion Matrix: ');print(table( nonLinear.prediction, nonlinear.test.output, dnn= c("prediction","reality") ))
nonLinear.prediction.score <- predict( nonlinear.svm, nonlinear.test.input, type='decision' )
require( 'ROCR' )
nonLinear.roc.curve <- performance( prediction( nonLinear.prediction.score, nonlinear.test.output ), measure='tpr', x.measure='fpr' )
plot( nonLinear.roc.curve )
nonlinear.svm <- ksvm( y ~ ., data=nonlinear.train, type='C-svc', kernel='laplacedot', kpar=list(sigma=1), C=4, scale=c() )
plot( nonlinear.svm, data=nonlinear.train )
nonLinear.prediction <- predict( nonlinear.svm, nonlinear.test.input)
load('nonlinearSol.RData')
print(paste0('Accuracy: ', 100*sum( nonLinear.prediction == nonlinear.test.output )/length(nonlinear.test.output), '%'))
print('Confusion Matrix: ');print(table( nonLinear.prediction, nonlinear.test.output, dnn= c("prediction","reality") ))
nonLinear.prediction.score <- predict( nonlinear.svm, nonlinear.test.input, type='decision' )
require( 'ROCR' )
nonLinear.roc.curve <- performance( prediction( nonLinear.prediction.score, nonlinear.test.output ), measure='tpr', x.measure='fpr' )
plot( nonLinear.roc.curve )
nonlinear.svm <- ksvm( y ~ ., data=nonlinear.train, type='C-svc', kernel='rbf', kpar=list(sigma=1), C=100, scale=c() )
plot( nonlinear.svm, data=nonlinear.train )
nonLinear.prediction <- predict( nonlinear.svm, nonlinear.test.input)
load('nonlinearSol.RData')
print(paste0('Accuracy: ', 100*sum( nonLinear.prediction == nonlinear.test.output )/length(nonlinear.test.output), '%'))
print('Confusion Matrix: ');print(table( nonLinear.prediction, nonlinear.test.output, dnn= c("prediction","reality") ))
nonLinear.prediction.score <- predict( nonlinear.svm, nonlinear.test.input, type='decision' )
require( 'ROCR' )
nonLinear.roc.curve <- performance( prediction( nonLinear.prediction.score, nonlinear.test.output ), measure='tpr', x.measure='fpr' )
plot( nonLinear.roc.curve )
nonLinear.pr.curve <- performance( prediction( nonLinear.prediction.score, nonlinear.test.output ), measure='prec', x.measure='rec' )
plot( nonLinear.pr.curve )
BiasVarianceTradeoff <- function( dataset, cross=10, c.seq=2^seq(-10, 10), ... ) {
err <- sapply( c.seq, function( c )
{
cross( ksvm( y ~ ., data=dataset, C=c, cross=cross, ...) )
})
return(data.frame( c=c.seq, error=err ))
}
qplot( c, error, data=BiasVarianceTradeoff( nonlinear.train, type='C-svc', kernel='rbfdot' ), geom='line', log='x' )
